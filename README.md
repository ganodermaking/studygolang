# studygolang-daily-interview

【go语言中文网】每日面试题及其解析

## day1

```text
打印后
打印中
打印前
```

参考解析：defer的执行顺序是后进先出。当出现panic语句的时候，会先按照defer的后进先出的顺序执行，最后才会执行panic。

### day2

```text
0 -> 3
1 -> 3
2 -> 3
3 -> 3
```

参考解析：这是新手常会犯的错误写法，for range循环的时候会创建每个元素的副本，而不是元素的引用，所以m[key] = &val取的都是变量val的地址，所以最后map中的所有元素的值都是变量val的地址，因为最后val被赋值为3，所有输出都是3。

正确的写法：

```go
func main() {
 slice := []int{0, 1, 2, 3}
 m := make(map[int]*int)

 for key, val := range slice {
  value := val
  m[key] = &value
 }

 for k, v := range m {
  fmt.Println(k, "===>", *v)
 }
}
```

### day3

1. 参考解析：这道题考的是使用append向slice添加元素，第一段代码常见的错误是[1 2 3]，需要注意。两段代码分别输出：

    ```text
    1[0 0 0 0 0 1 2 3]
    2[1 2 3 4]
    ```

2. 参考答案：第二个返回值没有命名。
 参考解析：
 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。这里的第一个返回值有命名 sum，第二个没有命名，所以错误。

3. 参考答案：
new(T) 和 make(T, args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。

new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。

make(T, args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.

### day4

1. 参考答案及解析：不能通过编译，new([]int) 之后的 list 是一个 *[]int 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。

2. 参考答案及解析：不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。

3. 参考答案及解析：不能通过编译。这道题的主要知识点是变量声明的简短模式，形如：x := 100。但这种声明方式有限制：

必须使用显示初始化；
不能提供数据类型，编译器会自动推导；
只能在函数内部使用简短模式；

### day5

编译不通过 invalid operation: sm1 == sm2
这道题目考的是结构体的比较，有几个需要注意的地方：
结构体只能比较是否相等，但是不能比较大小。
相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关，sn3 与 sn1 就是不同的结构体；

```go
sn3 := struct {
 name string
 age  int
}{age: 11, name: "qq"}
```

如果 struct 的所有成员都可以比较，则该 struct 就可以通过 == 或 != 进行比较是否相等，比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等；
那什么是可比较的呢，常见的有 bool、数值型、字符、指针、数组等，像切片、map、函数等是不能比较的。

### day6

Go面试题# 第6天答案解析，题目见截图

1. 参考答案及解析：AC。& 取址运算符，* 指针解引用。
2. 参考答案及解析：编译不通过，cannot use i (type int) as type MyInt1 in assignment。这道题考的是类型别名与类型定义的区别。第 5 行代码是基于类型 int 创建了新类型 MyInt1，第 6 行代码是创建了 int 的类型别名 MyInt2，注意类型别名的定义时 = 。所以，第 10 行代码相当于是将 int 类型的变量赋值给 MyInt1 类型的变量，Go 是强类型语言，编译当然不通过；而 MyInt2 只是 int 的别名，本质上还是 int，可以赋值。第 10 行代码的赋值可以使用强制类型转化 var i1 MyInt1 = MyInt1(i).

### day7

1. 参考答案及解析：BD。知识点：字符串连接。除了以上两种连接方式，还有 strings.Join()、buffer.WriteString()等。

2. 参考答案及解析：编译通过，输出：0 2 zz zz 5。知识点：iota 的使用。给大家贴篇文章，讲的很详细
icongolang 使用 iota - 迪克猪 - 博客园

3. 参考答案及解析：BD。知识点：nil 值。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看下方贴出的源码就知道，所以 D 是对的。

```go
type error interface {
 Error() string
}
```

### day8

1. 参考答案及解析：AB。关于 init() 函数有几个需要注意的地方：
1）init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等;
2）一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数；
3）同一个包中多个 init() 函数的执行顺序没有明确定义，但是不同包的init函数是根据包导入的依赖关系决定的（看下图）;
4）init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误;
5）一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次；
6）引入包，不可出现死循坏。即 A import B,B import A，这种情况编译失败；

2. 答案及解析：B。这道题目里面，是将 hello() 赋值给变量 h，而不是函数的返回值，所以输出 not nil。

3. 参考答案及解析：编译失败。考点：类型选择，类型选择的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型选择。

### day9

1. 参考答案及解析：ABC。A、B都是声明 channel；C 读取 channel；写 channel 是必须带上值，所以 D 错误。

2. 参考答案及解析：A。打印一个 map 中不存在的值时，返回元素类型的零值。这个例子中，m 的类型是 map[person]int，因为 m 中不存在 p，所以打印 int 类型的零值，即 0。

3. 参考答案及解析：18。知识点：可变函数。

### day10

1. 参考答案及解析：C。a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。

2. 参考答案及解析：B。知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：长度：j-i，容量：k-i。截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：j-i、k-i。所以例子中，切片t为[4]，长度和容量都是1。

3. 参考答案及解析：A。Go 中的数组是值类型，可比较，另外一方面，数组的长度也是数组类型的组成部分，所以a和b是不同的类型，是不能比较的，所以编译错误。

### day11

1. 参考答案及解析：ABD。知识点：cap()，cap() 函数不适用 map。

2. 参考答案及解析：A。当且仅当接口的动态值和动态类型都为nil时，接口类型值才为nil。

3. 参考答案及解析：B。删除 map 不存在的键值对时，不会报错，相当于没有任何作用；获取不存在的减值对时，返回值类型对应的零值，所以返回 0。

### day12

1. 参考答案及解析：ABD。知识点：Go 语言的关键字。Go语言有25个关键字。
2. 参考答案及解析：A。%d表示输出十进制数字，+表示输出数值的符号。这里不表示取反。
3. 参考答案及解析：teacher showB。知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。

### day13

1. 参考答案及解析：AD。B 只支持局部变量声明；C 是赋值，str 必须在这之前已经声明；
2. 参考答案及解析：5。这个例子中，hello() 函数的参数在执行defer语句的时候会保存一份副本，在实际调用hello()函数时用，所以是5。
3. 参考答案及解析：

```text
showA
showB
```

知识点：结构体嵌套。这道题可以结合第12天的第三题一起看，Teacher 没有自己ShowA()，所以调用内部类型 People的同名方法，需要注意的是第5行代码调用的是People自己的ShowB方法。

### day14

1. 参考代码及解析：C。知识点：常量，Go 语言中的字符串是只读的。
2. 参考答案及解析：B。知识点：指针，incr() 函数里的 p 是 *int 类型的指针，指向的是 main() 函数的变量 p 的地址。第 2 行代码是将该地址的值执行一个自增操作，incr() 返回自增后的结果。
3. 参考答案及解析：ABD。知识点：可变函数。

### day15

1. 参考答案及解析：A。知识点：nil 切片和空切片。nil 切片和 nil 相等，一般用来表示一个不存在的切片；空切片和 nil 不相等，表示一个空的集合。
2. 参考答案及解析：A。UTF-8 编码中，十进制数字 65 对应的符号是 A。
3. 参考答案及解析：13 23。知识点：接口。一种类型实现多个接口，结构体 Work 分别实现了接口 A、B，所以接口变量 a、b 调用各自的方法 ShowA() 和 ShowB()，输出 13、23。

### day16

1. 参考答案及解析：a、b、c 的长度和容量分别是 0 3、2 3、1 2。知识点：数组或切片的截取操作。截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，截取得到的切片长度和容量计算方法是 j-i、l-i。操作符 [i:j:k]，k 主要是用来限制切片的容量，但是不能大于数组的长度 l，截取得到的切片长度和容量计算方法是 j-i、k-i。

2. 在 A 处只声明了map m ,并没有分配内存空间，不能直接赋值，需要使用 make()，都提倡使用 make() 或者字面量的方式直接初始化 map。B 处，v, k := m["b"] 当 key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，k 返回 false。参考答案及解析：

     ```go
     func main() {
        m := make(map[string]int)
        m["a"] = 1
        if v, ok := m["b"]; ok {
            fmt.Println(v)
        }
    }
    ```

3. 参考答案及解析：B。知识点：接口的静态类型。a、b 具有相同的动态类型和动态值，分别是结构体 work 和 {3}；a 的静态类型是 A，b 的静态类型是 B，接口 A 不包括方法 ShowB()，接口 B 也不包括方法 ShowA()，编译报错。看下编译错误：

    ```text
    a.ShowB undefined (type A has no field or method ShowB)
    b.ShowA undefined (type B has no field or method ShowA)
    ```

### day17

1. 参考答案及解析：错、对、对、错。知识点：变量的声明。1.错，x 已经声明，不能使用 :=；2.对；3.对，当多值赋值时，:= 左边的变量无论声明与否都可以；4.错，y 没有声明。

2. 参考答案及解析：B。知识点：defer、返回值。注意一下，increaseA() 的返回参数是匿名，increaseB() 是具名。关于 defer 与返回值的知识点，后面我会写篇文章详细分析，到时候可以看下文章的讲解。

分解如下：

```go
func increaseB() (r int) {
 // 1.赋值
 r = 0
 // 2.闭包引用，r++
 defer func() {
  r++
 }()
 // 3.空 return
 return
}
```

大家可能注意到，函数 increaseA() 是匿名返回值，返回局部变量，同时 defer 函数也会操作这个局部变量。对于匿名返回值来说，可以假定有一个变量存储返回值，比如假定返回值变量为 anony，由于i是整型，会将值拷贝给anony，所以defer语句中修改i值，对函数返回值不造成影响，所以返回0。上面的返回语句可以拆分成以下过程：

```text
annoy = i i++ return
```

3. 参考答案及解析：A。知识点：类型断言。

### day18

什么是 defer

defer 是 Go 语言提供的一种用于注册延迟调用的机制，每一次 defer 都会把函数压入栈中，当前函数返回前再把延迟函数取出并执行。

defer 语句并不会马上执行，而是会进入一个栈，函数 return 前，会按先进后出（FILO）的顺序执行。也就是说最先被定义的 defer 语句最后执行。先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。

采坑点：
使用 defer 最容易采坑的地方是和带命名返回参数的函数一起使用时。defer 语句定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在 defer 定义时就把值传递给 defer，并被缓存起来；作为闭包引用的话，则会在 defer 函数真正调用时根据整个上下文确定当前的值。

避免掉坑的关键是要理解这条语句：

```text
return xxx
```

这条语句并不是一个原子指令，经过编译之后，变成了三条指令：

1. 返回值 = xxx
2. 调用 defer 函数
3. 空的 return

> 1,3步才是 return 语句真正的命令，第 2 步是 defer 定义的语句，这里就有可能会操作返回值。我们试着用上面的拆解方式，给出自己的答案，再往下看！
第一题拆解过程：

```go
func f1() (r int) {
 // 1.赋值
 r = 0

 // 2.闭包引用，返回值被修改
 defer func() {
  r++
 }()

 // 3.空的 return
 return
}
```

> defer 是闭包引用，返回值被修改，所以 f() 返回 1。

第二题拆解过程：

```go
func f2() (r int) {
 t := 5
 // 1.赋值
 r = t
 // 2.闭包引用，但是没有修改返回值 r
 defer func() {
  t = t + 5
 }()
 // 3.空的 return
 return
}
```

> 第二步没涉及返回值 r 的操作，所以返回 5。

第三题拆解过程：

```go
func f3() (r int) {
 // 1.赋值
 r = 1
 // 2.r 作为函数参数，不会修改要返回的那个 r 值
 defer func(r int) {
  r = r + 5
 }(r)
 // 3.空的 return
 return
}
```

> 第二步，r 是作为函数参数使用，是一份复制，defer 语句里面的 r 和 外面的 r 其实是两个变量，里面变量的改变不会影响外层变量 r，所以不是返回 6 ，而是返回 1。

### day19

参考答案及解析：29 29 28。变量 person 是一个指针变量 。

1. person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；

2. defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；

3. 闭包引用，输出 29；

又由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 29 28。

### day20

1. 参考答案及解析：C。被调用函数里的 defer 语句在返回之前就会被执行，所以输出顺序是 F D M。

2. 参考答案及解析：29 28 28。这道题在第 19 天题目的基础上做了一点点小改动，前一题最后一行代码 person.age = 29 是修改引用对象的成员 age，这题最后一行代码 person = &Person{29} 是修改引用对象本身，来看看有什么区别。

1处.person.age 这一行代码跟之前含义是一样的，此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；

2处.defer 缓存的是结构体 Person{28} 的地址，这个地址指向的结构体没有被改变，最后 defer 语句后面的函数执行的时候取出仍是 28；

3处.闭包引用，person 的值已经被改变，指向结构体 Person{29}，所以输出 29.

由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 28 28。

### day21

1. 参考答案及解析：A 声明的是 nil 切片；B 声明的是长度和容量都为 0 的空切片。第一种切片声明不会分配内存，优先选择。

2. 参考答案及解析：BD。函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等，即使是接收指针类型也用 interface{}，而不是使用 *interface{}。永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。

3. 参考答案及解析：
A. &S{"foo"}
B. *f() 或者 f()
f() 函数返回参数是指针类型，所以可以用 & 取结构体的指针；B 处，如果填*f()，则 p 是 S 类型；如果填 f()，则 p 是 *S 类型，不过都可以使用 p.m 取得结构体的成员。

### day22

1. 参考答案及解析：两个地方有语法问题。golang 的字符串类型是不能赋值 nil 的，也不能跟 nil 比较。
2. 参考答案及解析：2 1。defer 关键字后面的函数或者方法想要执行必须先注册，return 之后的 defer 是不能注册的， 也就不能执行后面的函数或方法。

### day23

1. 我们知道，golang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组，这会导致 s2[1] = 4 语句影响 s1。而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1。但是为什么对 s2 赋值后影响的却是 s1 的第三个元素呢？这是因为切片 s2 是从数组的第二个元素开始，s2 索引为 1 的元素对应的是 s1 索引为 2 的元素。参考答案及解析：

    ```text
    [1 2 4]
    [1 2 4]
    ```

2. 参考答案及解析：A。知识点：代码块和变量作用域。

### day24

1. 参考答案及解析：0 zero 1 one 或者 1 one 0 zero，map 的输出是无序的。

2. 参考答案及解析：

```text
10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4
```

程序执行到 main() 函数三行代码的时候，会先执行 calc() 函数的 b 参数，即：calc("10",a,b)，输出：10 1 2 3，得到值 3，因为
defer 定义的函数是延迟函数，故 calc("1",1,3) 会被延迟执行；

程序执行到第五行的时候，同样先执行 calc("20",a,b) 输出：20 0 2 2 得到值 2，同样将 calc("2",0,2) 延迟执行；

程序执行到末尾的时候，按照栈先进后出的方式依次执行：calc("2",0,2)，calc("1",1,3)，则就依次输出：2 0 2 2，1 1 3 4。

### day25

1. 参考答案及解析：B。基于类型创建的方法必须定义在同一个包内，上面的代码基于 int 类型创建了 PrintInt() 方法，由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。解决的办法可以定义一种新的类型：

    ```go
    type Myint int

    func (i Myint) PrintInt ()  {
        fmt.Println(i)
    }

    func main() {
        var i Myint = 1
        i.PrintInt()
    }
    ```

2. 参考答案及解析：B。编译错误 Student does not implement People (Speak method has pointer receiver)，值类型 Student 没有实现接口的 Speak() 方法，而是指针类型 *Student 实现该方法。

### day26

1. 参考答案及解析：0 1 1 2。知识点：iota 的用法。iota 是 golang 语言的常量计数器，只能在常量的表达式中使用。iota 在 const 关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次。

2. 参考答案及解析：s is nil 和 p is not nil。这道题会不会有点诧异，我们分配给变量 p 的值明明是 nil，然而 p 却不是 nil。记住一点，当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。上面的代码，给变量 p 赋值之后，p 的动态值是 nil，但是动态类型却是 *Student，是一个 nil 指针，所以相等条件不成立。

### day27

1. 参考答案及解析：South。知识点：iota 的用法、类型的 String() 方法。根据 iota 的用法推断出 South 的值是 3；另外，如果类型定义了 String() 方法，当使用 fmt.Printf()、fmt.Print() 和 fmt.Println() 会自动使用 String() 方法，实现字符串的打印。

2. 参考答案及解析：B，编译报错 cannot assign to struct field m["foo"].x in map。错误原因：对于类似 X = Y的赋值操作，必须知道 X 的地址，才能够将 Y 的值赋给 X，但 go 中的 map 的 value 本身是不可寻址的。有两个解决办法：
1.使用临时变量

```go
type Math struct {
    x, y int
}

var m = map[string]Math{
    "foo": Math{2, 3},
}

func main() {
    tmp := m["foo"]
    tmp.x = 4
    m["foo"] = tmp
    fmt.Println(m["foo"].x)
}
```

2.修改数据结构

```go
type Math struct {
    x, y int
}

var m = map[string]*Math{
    "foo": &Math{2, 3},
}

func main() {
    m["foo"].x = 4
    fmt.Println(m["foo"].x)
    fmt.Printf("%#v", m["foo"])   // %#v 格式化输出详细信息
}
```

### day28

1. 参考答案及解析：有两处错误。go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 […]int{1} 和 [2]int{1} 是两种不同的类型，不能比较；切片是不能比较的；

2. 参考答案及解析：B。知识点：变量作用域。问题出在操作符:=，对于使用:=定义的变量，如果新变量与同名已定义的变量不在同一个作用域中，那么 Go 会新定义这个变量。对于本例来说，main() 函数里的 p 是新定义的变量，会遮住全局变量 p，导致执行到bar()时程序，全局变量 p 依然还是 nil，程序随即 Crash。正确的做法是将 main() 函数修改为：

```go
func main() {
    var err error
    p, err = foo()
    if err != nil {
        fmt.Println(err)
        return
    }
    bar()
    fmt.Println(*p)
}
```

### day29

1. 参考答案及解析：不会出现死循环，能正常结束。
循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数。

2. 参考答案及解析：

```text
2 3
2 3
2 3
```

for range 使用短变量声明(:=)的形式迭代变量，需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个goroutine启动时的i, v值。可以理解为闭包引用，使用的是上下文环境的值。两种可行的 fix 方法:

1.使用函数传递

```go
for i, v := range m {
    go func(i,v int) {
        fmt.Println(i, v)
    }(i,v)
}
```

2.使用临时变量保留当前值

```go
for i, v := range m {
    i := i           // 这里的 := 会重新声明变量，而不是重用
    v := v
    go func() {
        fmt.Println(i, v)
    }()
}
```

### day30

1. 参考答案及解析：7。根据 5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！ 提到的“三步拆解法”，第一步执行r = n +1，接着执行第二个 defer，由于此时 f() 未定义，引发异常，随即执行第一个 defer，异常被 recover()，程序正常执行，最后 return。

2. 参考答案及解析：

```go
r =  [1 2 3 4 5]
a =  [1 12 13 4 5]
```

range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a。就这个例子来说，假设 b 是 a 的副本，则 range 循环代码是这样的：

```go
for i, v := range b {
    if i == 0 {
        a[1] = 12
        a[2] = 13
    }
    r[i] = v
}
```

因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。如果想要 r 和 a 一样输出，修复办法：

```go
func main() {
    var a = [5]int{1, 2, 3, 4, 5}
    var r [5]int

    for i, v := range &a {
        if i == 0 {
            a[1] = 12
            a[2] = 13
        }
        r[i] = v
    }
    fmt.Println("r = ", r)
    fmt.Println("a = ", a)
}
```

输出：

```text
r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
```

修复代码中，使用 *[5]int 作为 range 表达式，其副本依旧是一个指向原数组 a 的指针，因此后续所有循环中均是 &a 指向的原数组亲自参与的，因此 v 能从 &a 指向的原数组中取出 a 修改后的值。

### day31

1. 知识点：可变函数、append()操作。Go 提供的语法糖...，可以将 slice 传进可变函数，不会创建新的切片。第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变；第二次调用change() 函数时，使用了操作符[i,j]获得一个新的切片，假定为 slice1，它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。参考答案及解析：

    ```text
    [1 2 0 0 0]
    [1 2 3 0 0]
    ```

2. 参考答案及解析：

```go
r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
```

这道题是 第30天 的第二题的一个解决办法，这的 a 是一个切片，那切片是怎么实现的呢？切片在 go 的内部结构有一个指向底层数组的指针，当 range 表达式发生复制时，副本的指针依旧指向原底层数组，所以对切片的修改都会反应到底层数组上，所以通过 v 可以获得修改后的数组元素。

### day32

1. 参考答案及解析：s2 的输出结果错误。s2 的输出是 &{C} &{C} &{C}，在 第 30 天 的答案解析第二题，我们提到过，for range 使用短变量声明(:=)的形式迭代变量时，变量 i、value 在每次循环体中都会被重用，而不是重新声明。所以 s2 每次填充的都是临时变量 value 的地址，而在最后一次循环中，value 被赋值为{c}。因此，s2 输出的时候显示出了三个 &{c}。可行的解决办法如下：

    ```go
    for i := range s1 {
        s2[i] = &s1[i]
    }
    ```

2. 参考答案及解析：C。for range map 是无序的，如果第一次循环到 A，则输出 3；否则输出 2。

### day33

1. 参考答案及解析：AD。
2. 参考答案及解析：CD。
3. 参考答案及解析：A。知识点：多重赋值。

多重赋值分为两个步骤，有先后顺序。计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式赋值。所以本例，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 i, s[0] = 2, "Z"。

### day34

1. 参考答案及解析：C。知识点：强制类型转化。
2. 参考答案及解析：BD。参考文章 条件语句和循环语句。
3. 参考答案及解析：AC。知识点：类型断言、方法集。

### day35

1. 参考答案及解析：BC。
2. 参考答案及解析：AD。知识点：自增自减操作。i++和i--在Go语言中是语句，不是表达式，因此不能赋值给另外的变量。此外没有++i和--i。
3. 参考答案及解析：ACD。
